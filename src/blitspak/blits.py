"""
Blits:
Created on 23 May 2017
Original Blivion:
Created on Tue Oct 25 13:11:32 2016

@author: Maria Schilstra
"""

#from PyQt5.uic import loadUiType

from PyQt5 import QtCore as qt
from PyQt5 import QtWidgets as widgets
from PyQt5 import QtGui as gui

import pandas as pd, numpy as np, copy as cp


from matplotlib.widgets import SpanSelector
from blitspak.blits_mpl import MplCanvas, NavigationToolbar
from blitspak.blits_data import BlitsData
from blitspak.scrutinize_dialog import ScrutinizeDialog
from blitspak.function_dialog import FunctionSelectionDialog
from blitspak.data_creation_dialog import DataCreationDialog
from blitspak.crux_table_model import CruxTableModel
from functions.framework import FunctionsFramework

#import blitspak.blits_ui as ui
from PyQt5.uic import loadUiType
Ui_MainWindow, QMainWindow = loadUiType('..\\..\\Resources\\UI\\blits.ui')

# Original:
# To avoid using .ui file (from QtDesigner) and loadUIType, 
# created a python-version of the .ui file using pyuic5 from command line
# Here: pyuic5 blits.ui -o blits_ui.py
# Also: cannot (easily) use .qrc file, so need to create _rc.py file
# with icon definitions: pyrcc5 -o blits_rc.py blits.qrc
# Then import .py package, as below.
# (QMainWindow is a QtWidget; UI_MainWindow is generated by the converted .ui)



class Main(QMainWindow, Ui_MainWindow):
    
    NSTATES = 6
    START, DATA_ONLY, FUNCTION_ONLY, READY_FOR_FITTING, FITTED, REJECT = range(NSTATES)
#     readiness = (1, 2)
#     DATA_SET, FUNCTION_SET = readiness

    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)

        self.scrutinize_dialog = None
        self.function_dialog = None
        self.create_data_set_dialog = None
        
        self.canvas = MplCanvas(self.mpl_window)
        self.plot_toolbar = NavigationToolbar(self.canvas, self.mpl_window)
        self.mpl_layout.addWidget(self.canvas)
        self.grp_show_axis = widgets.QGroupBox()
        self.axis_layout = widgets.QHBoxLayout()
        self.grp_show_axis.setLayout(self.axis_layout)
        self.mpl_layout.addWidget(self.grp_show_axis)
        self.mpl_layout.addWidget(self.plot_toolbar)
        
        self.action_open.triggered.connect(self.on_open)
        self.action_create.triggered.connect(self.on_create)
        self.action_close.triggered.connect(self.on_close_data)
        self.action_save.triggered.connect(self.on_save)
        self.action_select_function.triggered.connect(self.on_select_function)
        self.action_analyze.triggered.connect(self.on_analyze)
        self.action_quit.triggered.connect(self.close)     

        self.span = SpanSelector(self.canvas.data_plot, 
                                 self.on_select_span, 
                                 'horizontal', 
                                 useblit=True, 
                                 rectprops=dict(alpha=0.5, facecolor='red')
                                 )
        
        self.blits_data = BlitsData()
        self.blits_fitted = BlitsData()
        self.blits_residuals = BlitsData()
        self.file_name = ""
        self.file_path = ""
        self.phase_number = 0
        self.phase_name = "Phase"
        self.phase_list = []
        self.axis_selector_buttons = None
        self.current_function = None
        
        self.current_state = self.START        
        self.update_ui()
        
    def on_open(self):
        if self.current_state in (self.START, self.FUNCTION_ONLY, ):
            file_path = widgets.QFileDialog.getOpenFileName(self, 
            "Open Data File", "", "CSV data files (*.csv);;All files (*.*)")[0]
            if file_path:
                self.file_path = file_path
                info = qt.QFileInfo(file_path)
                self.blits_data.file_name = info.fileName()
                self.blits_data.import_data(file_path)
                self.current_xaxis = self.blits_data.independent_names[0]
                if self.current_state == self.START:
                    self.current_state = self.DATA_ONLY
                else:
                    self.current_state = self.READY_FOR_FITTING
                self.create_axis_selection_box()
                self.set_current_function_ui()
                self.update_ui()
                
    def on_create(self):  
        if self.current_state in (self.FUNCTION_ONLY, ):
            self.create_data_set_dialog = DataCreationDialog(None, self.current_function)
            if self.create_data_set_dialog.exec() == widgets.QDialog.Accepted:
                template = self.create_data_set_dialog.template
                self.set_params_view(template[1])
                self.blits_data.create_working_data_from_template(template)
                self.current_state = self.READY_FOR_FITTING
                self.current_xaxis = self.blits_data.independent_names[0]
                self.create_axis_selection_box()
                self.update_ui()
                
    def on_close_data(self):
        if self.current_state in (self.DATA_ONLY, self.READY_FOR_FITTING, self.FITTED, ):
            self.blits_data = BlitsData()
            self.current_xaxis = None
            self.create_axis_selection_box()
            self.canvas.clear_figure()
            
            if self.current_state == self.DATA_ONLY:
                self.current_state = self.START
            else:
                self.current_state = self.FUNCTION_ONLY
                
            self.set_current_function_ui()
            self.update_ui()

    def on_select_function(self):
        if self.current_state in range(self.NSTATES):  # should work from all states
            name, n_axes = "", np.inf
            if not self.current_state in (self.START, self.DATA_ONLY):  # a current function exists
                name = self.current_function.name
            if self.current_state in (self.DATA_ONLY, self.READY_FOR_FITTING, self.FITTED):
                n_axes = len(self.blits_data.independent_names)
            self.function_dialog = FunctionSelectionDialog(self, n_axes=n_axes, selected_fn_name=name)
            if self.function_dialog.exec() == widgets.QDialog.Accepted:
                self.current_function = self.function_dialog.get_selected_function()
                if self.current_state in (self.START, self.FUNCTION_ONLY):
                    self.current_state = self.FUNCTION_ONLY
                else:
                    self.current_state = self.READY_FOR_FITTING
                self.set_current_function_ui()
                self.update_ui()    

    def set_params_view(self, df_pars):
        self.tbl_params.setModel(None)
        chkable = list(range(len(df_pars.columns)))
        self.parameters_model = CruxTableModel(df_pars, chkable)
        self.tbl_params.setModel(self.parameters_model)
        self.tbl_params.setSizeAdjustPolicy(widgets.QAbstractScrollArea.AdjustToContents)

                
    def set_current_function_ui(self):        
        if self.current_state in (self.DATA_ONLY, self.START, ): # there is no self.current_functions
            self.parameters_model = None
            self.tbl_params.setModel(None)
        else:
            indx_pars = self.current_function.parameters
            cols_pars = [] 
            if self.current_state in (self.READY_FOR_FITTING, self.FITTED):
                cols_pars = self.blits_data.series_names
            df_pars = pd.DataFrame(np.ones((len(indx_pars), len(cols_pars)), dtype=float), index=indx_pars, columns=cols_pars) 
            self.set_params_view(df_pars)                   
            self.lbl_fn_name.setText("Selected function: " + self.current_function.name)
            self.txt_description.setText(self.current_function.long_description)
                
    def create_axis_selection_box(self):
        self.axis_selector_buttons = {}
        self.clearLayout(self.axis_layout)
        if self.blits_data.has_data():
            self.axis_layout.addStretch()
            for name in self.blits_data.independent_names:
                btn = widgets.QRadioButton()
                btn.setText(name)
                btn.toggled.connect(self.on_xaxis_state_changed)
                self.axis_layout.addWidget(btn)
                self.axis_selector_buttons[btn.text()] = btn
            self.axis_layout.addStretch()  
            if not self.current_xaxis is None:
                self.axis_selector_buttons[self.current_xaxis].setChecked(True)
            
    def on_xaxis_state_changed(self, checked):
        btn = self.sender()
        xaxis = btn.text()
        if btn.isChecked():
            self.current_xaxis = xaxis
            self.draw_current_data_set()   
            
    def get_selected_series_names(self):
        cols = cp.deepcopy(self.parameters_model.df_data.columns)
        return cols.tolist()
    
    def get_data_for_fitting(self, series_names):
        data = []
        for s in series_names:
            selection = cp.deepcopy(self.blits_data.series_dict[s]).as_matrix().transpose()
            if len(data) == 0:
                data = [selection]
            else:
                data.append(selection)
        return data
    
    def get_param_values_from_table(self, series_names):
        """
        Returns an (n_curves, n_params)-shaped array (with rows and columns 
        parallel to self.series_names and self.current_function.parameters, 
        respectively) with values for each parameter for each series).  
        """
        return cp.deepcopy(self.parameters_model.df_data)[series_names].as_matrix().transpose()
    
    def get_constant_params_from_table(self, series_names):
        """
        Returns an (n_curves, n_params)-shaped array of Boolean values 
        (with rows and columns parallel to self.series_names and self.current_function.parameters, 
        respectively) with values for each parameter for each series); if True, 
        parameter values is constant, if False, parameter value is variable.
        """
        return cp.deepcopy(self.parameters_model.df_checks)[series_names].as_matrix().transpose()
        
    def get_linked_params_from_table(self, series_names):
        """
        Returns an (n_curves, n_params)-shaped array (with rows and columns parallel to 
        self.series_names and self.current_function.parameters, respectively)
        of integers, in which linked parameters are grouped by their values.
        Example for 4 curves and 3 parameters:
              p0    p1    p2
        c0    0     2     3
        c1    0     2     4
        c2    1     2     5
        c3    1     2     6
        indicates that parameter p0 is assumed to have the same value in 
        curves c0 and c1, and in curves c2 and c3 (a different value), 
        and that the value for p1 is the same in all curves, whereas
        the value of p2 is different for all curves. 
        """
        shape = self.parameters_model.df_data.shape
        
        links_array = np.arange(shape[0] * shape[1]).reshape((shape[0], shape[1])).transpose()
#         ncol_per_param = len(self.params_table_headers) - 2 #3
#         if self.chk_global.checkState() == qt.Qt.Checked:
#             ncol_per_param += 1                 
# 
#         funcname = self.cmb_fit_function.currentText()
#         param_names = list(self.fn_dictionary[funcname][self.d_pnames])
#         
#         nparams = len(param_names)
#         ncurves = len(self.series_names) 
#         links = np.arange(nparams * ncurves, dtype=int)
#         links = np.reshape(links, (nparams, ncurves))
#         
#         if self.chk_global.checkState() == qt.Qt.Checked:
#             l_locs = np.arange(0, nparams * ncol_per_param, ncol_per_param) + self.head_share
#             pcount, indpcount = 0, 0
#             for lloc in l_locs:
#                 # Find all connections (reflexive, symmetrical, transitive graph)
#                 mlinks = np.identity(ncurves, dtype=int) # Make matrix reflexive
#                 for irow in range(self.tbl_params.rowCount()):
#                     cname = self.tbl_params.verticalHeaderItem(irow).text()
#                     if cname in self.series_names:
#                         linked = self.tbl_params.cellWidget(irow, lloc).currentText()
#                         cind = self.series_names.index(cname)
#                         lind = self.series_names.index(linked)
#                         mlinks[cind, lind] = 1
#                         mlinks[lind, cind] = 1 # Make matrix symmetrical
#                 # Warshall-Floyd to make matrix transitive 
#                 for k in range(ncurves):
#                     for i in range(ncurves):
#                         for j in range(ncurves):
#                             mlinks[i, j] = mlinks[i, j] or (mlinks[i, k] == 1 and mlinks[k, j] == 1)
#                 # Find the equivalence classes for this parameter 
#                 scrap = np.ones((ncurves,), dtype=bool)
#                 eq_classes = []
#                 for k in range(ncurves):
#                     if scrap[k]:
#                         ec = np.where(mlinks[k] == 1)
#                         eq_classes.append(ec[0])
#                         scrap[ec] = False
#                 # Number the individual equivalence classes
#                 ind_params = np.empty_like(self.series_names, dtype=int)
#                 for i in eq_classes:
#                     ind_params[i] = indpcount
#                     indpcount += 1
#                 links[pcount] = ind_params
#                 pcount += 1
#         
#         selected = [self.series_names.index(name) for name in series_names]  
#         links_array = links.transpose()[selected]
        return links_array
         
         
    def perform_fit(self):
        func = self.current_function.func
        series_names = self.get_selected_series_names()
        data = self.get_data_for_fitting(series_names)
        param_values = self.get_param_values_from_table(series_names)
        const_params = self.get_constant_params_from_table(series_names)             
        links = self.get_linked_params_from_table(series_names)
        fitted_params = cp.deepcopy(param_values)
        sigmas = np.empty_like(fitted_params)
        confidence_intervals = np.empty_like(fitted_params)
        tol = None
        results = None  
        ffw = FunctionsFramework()
        if self.chk_global.checkState() == qt.Qt.Checked:
            results = ffw.perform_global_curve_fit(data, func, param_values, const_params, links)
            fitted_params = results[0]
            sigmas = results[1]
            confidence_intervals = results[2]
            tol = results[3]
        else:
            tol = []
            n = 0
            for d, p, c, l in zip(data, param_values, const_params, links):
                d = [d, ]
                p = np.reshape(p, (1, p.shape[0]))
                c = np.reshape(c, (1, c.shape[0]))
                l = np.reshape(l, (1, l.shape[0]))
                results = ffw.perform_global_curve_fit(d, func, p, c, l)
                fitted_params[n] = results[0]
                sigmas[n] = results[1]
                confidence_intervals[n] = results[2]
                tol.append(results[3])
                n += 1
        return fitted_params, sigmas, confidence_intervals, tol
    
    def create_fitted_curves(self, params, n_points):
        mins, maxs = self.blits_data.series_extremes()
        indx = mins.index
        series_names = mins.columns
        series_dict = {}
        for series, ps in zip(mins, params.transpose()):
            df_data = pd.DataFrame(index=[], columns=range(n_points))
            for v0, v1 in zip(mins[series].iloc[:-1], maxs[series].iloc[:-1]):
                x = pd.DataFrame(np.linspace(v0, v1, n_points)).transpose()
                df_data = pd.concat((df_data, x))
            x = df_data.as_matrix()
            y = pd.DataFrame(self.current_function.func(x, ps)).transpose()
            df_data = pd.concat((df_data, y))
            lindx = indx.tolist()[:-1]
            lindx.append(series)
            df_data.index = lindx
            series_dict[series] = df_data.transpose()
        self.blits_fitted = BlitsData()
        self.blits_fitted.series_names = np.array(series_names.tolist())
        self.blits_fitted.independent_names = np.array(indx.tolist())[:-1]
        self.blits_fitted.series_dict = series_dict
                       
    def on_analyze(self):
        if self.current_state in (self.READY_FOR_FITTING, self.FITTED):
            fitted_params, sigmas, confidence_intervals, tol = self.perform_fit()
            self.create_fitted_curves(fitted_params, 10)
            self.draw_current_data_set()
            
            
            
                
                
                
#                 smin, smax = np.finfo(float).max, np.finfo(float).min
#                 for name in series_names:
#                     mi, ma = self.blits_data.series_dict[name][self.current_xaxis].min(), self.blits_data.series_dict[name][self.current_xaxis].max()
#                     if ma > smax:
#                         smax = ma
#                     if mi < smin:
#                         smin = mi  
#                 x = np.linspace(smin, smax, 100)
                
                                      
#                     df_si = self.series_axes_info[name][0].df_data # axes start, stop, and std on data
#                     n = 100
#                     std = float(self.series_axes_info[name][2].text())
#                     cols = df_si.index # independent axes names
#                     df_s = pd.DataFrame([], index=range(n), columns=cols) # dataframe for axes values
#                     for col in cols:
#                         df_s[col] = np.linspace(df_si.iloc[:,0][col], df_si.iloc[:,1][col], n)
#                     x = cp.deepcopy(df_s).as_matrix().transpose() # copy axes values and transpose for use in self.function
#                     params = cp.deepcopy(df_p).as_matrix()
#                     vals = pd.DataFrame([], index=range(n), columns=[name]) # dataframe for dependent values
#                     y = self.function.func(x, params)
#                     if std > 0:
#                         y = norm.rvs(loc=y, scale=std)
#                     vals[name] = y
#                     
#                     df_s = pd.concat([df_s, vals], axis=1)
#                     df_all_series = pd.concat([df_all_series, df_s], axis=1)
#                     
#                 template = (df_all_series, df_all_parameters, self.function)            
            
            
            self.current_state = self.FITTED
            self.update_ui()

    def on_save(self):
        file_path = ""
        if self.current_state in (self.DATA_ONLY, self.READY_FOR_FITTING, ):
            file_path = widgets.QFileDialog.getSaveFileName(self, 
            "Save data", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if self.current_state in (self.FITTED, ):
            file_path = widgets.QFileDialog.getSaveFileName(self, 
            "Save results", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if file_path:
            pass
#             self.blits_data.export_results(file_path)
            
    def on_select_span(self, xmin, xmax):
        self.span.set_active(False)
        if (xmin != xmax):
            phase_id = self.phase_name + '{:0d}'.format(self.phase_number + 1)
            self.scrutinize_dialog = ScrutinizeDialog(main, xmin, xmax) 
            flags = self.scrutinize_dialog.windowFlags() | qt.Qt.WindowMinMaxButtonsHint
            self.scrutinize_dialog.setWindowFlags(flags)
            if self.scrutinize_dialog.show() == widgets.QDialog.Accepted:
                self.phase_number += 1
                self.phase_list.append(phase_id)
                model = self.scrutinize_dialog.current_function
                model_expr = self.scrutinize_dialog.fn_dictionary[model][self.scrutinize_dialog.d_expr]
                m_string = model + ': ' + model_expr
                tbl_results = self.scrutinize_dialog.tbl_results
                self.create_results_tab(phase_id, m_string, tbl_results)
            self.action_analyze.setChecked(False)
            self.on_analyze()

    def create_results_tab(self, phase_id, model_string, results_table):
        new_tab = widgets.QWidget()
        lo = widgets.QVBoxLayout(new_tab)
        x = widgets.QLabel(model_string)
        lo.addWidget(x)
        lo.addWidget(results_table)
        new_tab.setLayout(lo)
        self.tabWidget.addTab(new_tab, phase_id)

    def draw_current_data_set(self):
        self.canvas.clear_plots() 
        self.canvas.set_colours(self.blits_data.series_names.tolist())
        for key in self.blits_data.series_names:
            series = self.blits_data.series_dict[key]
            x = series[self.current_xaxis] 
            y = series[key] 
            self.canvas.draw_series(key, x, y)
        if self.blits_fitted.has_data():
            for key in self.blits_fitted.series_names:
                series = self.blits_fitted.series_dict[key]
                x = series[self.current_xaxis] 
                y = series[key] 
                self.canvas.draw_series(key, x, y)
            
            
#             
### From scrutinize_dialog
#         self.canvas.clear_plots() 
#         # lines have been cleared, so must be reconstructed
# #         self.line0 = DraggableLine(self.canvas.data_plot.axvline(self.x_inner_limits[0], lw=1, ls='--', color='k'), self.x_inner_limits)
# #         self.line1 = DraggableLine(self.canvas.data_plot.axvline(self.x_inner_limits[1], lw=1, ls='--', color='k'), self.x_inner_limits)           
#         series = self.get_selected_series_names()
#         xmin, xmax = np.finfo(np.float).max, np.finfo(np.float).min
#         for key in series:
#             selected = self.full_data[key]
#             selected.sort_values(by=self.current_xaxis, inplace=True)
#             xmin_series, xmax_series = selected[self.current_xaxis].min(), selected[self.current_xaxis].max()
#             if xmin_series < xmin:
#                 xmin = selected[self.current_xaxis].min()
#             if xmax_series > xmax:
#                 xmax = np.max(selected[self.current_xaxis])
#             x = selected[self.current_xaxis]
#             y = selected[self.y_name]
#             self.canvas.draw_series(key, x, y)
#             if key in self.fitted_data:
#                 self.fitted_data[key].sort_values(by=self.current_xaxis, inplace=True)
#                 x_fit = self.fitted_data[key][self.current_xaxis]
#                 y_fit = self.fitted_data[key][self.y_name]
#                 self.canvas.draw_series_fit(key, x_fit, y_fit)
#                 
#             if key in self.fit_residuals:
#                 self.fit_residuals[key].sort_values(by=self.current_xaxis, inplace=True)
#                 x_res = self.fit_residuals[key][self.current_xaxis]
#                 y_res = self.fit_residuals[key][self.y_name]
#                 self.canvas.draw_series_residuals(key, x_res, y_res)            
            
    def clearLayout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget() is not None:
                child.widget().deleteLater()
            elif child.layout() is not None:
                self.clearLayout(child.layout())            
                                    
    def line_icon(self, color):
        pixmap = gui.QPixmap(50,10)
        pixmap.fill(gui.QColor(color))
        icon = gui.QIcon(pixmap)
        return icon  
    
    def circle_icon(self, color):
        pix = gui.QPixmap(30,30)
        pix.fill(gui.QColor("transparent"))
        paint = gui.QPainter()
        paint.begin(pix)
        paint.setBrush(gui.QColor(color))
        paint.setPen(gui.QColor("transparent"))
        paint.drawEllipse(0,0,30,30)
        paint.end()
        icon = gui.QIcon(pix)
        return icon        

    def is_number(self, s):
        try:
            float(s)
            return True
        except ValueError:
            return False  
        
    def update_ui(self):
        if self.current_state == self.START:
            self.action_open.setEnabled(True)
            self.action_create.setEnabled(False)
            self.action_close.setEnabled(False)
            self.action_save.setEnabled(False)
            self.action_select_function.setEnabled(True)
            self.action_analyze.setEnabled(False)
            self.action_quit.setEnabled(True)     
            self.span.set_active(False)
        elif self.current_state == self.DATA_ONLY:
            self.action_open.setEnabled(False)
            self.action_create.setEnabled(False)
            self.action_close.setEnabled(True)
            self.action_save.setEnabled(True)
            self.action_select_function.setEnabled(True)
            self.action_analyze.setEnabled(False)
            self.action_quit.setEnabled(True) 
            self.span.set_active(False)
        elif self.current_state == self.FUNCTION_ONLY:
            self.action_open.setEnabled(True)
            self.action_create.setEnabled(True)
            self.action_close.setEnabled(False)
            self.action_save.setEnabled(False)
            self.action_select_function.setEnabled(True)
            self.action_analyze.setEnabled(False)
            self.action_quit.setEnabled(True)     
            self.span.set_active(False)
        elif self.current_state == self.READY_FOR_FITTING:
#             if self.action_analyze.isChecked():
#                 self.plot_toolbar.switch_off_pan_zoom()
#                 self.span.set_active(True)   
#             else:
#                 self.span.set_active(False)  
            self.action_open.setEnabled(False)
            self.action_create.setEnabled(False)
            self.action_close.setEnabled(True)
            self.action_save.setEnabled(True)
            self.action_select_function.setEnabled(True)
            self.action_analyze.setEnabled(True)
            self.action_quit.setEnabled(True)     
            self.span.set_active(False)
        elif self.current_state == self.FITTED:
            self.action_open.setEnabled(False)
            self.action_create.setEnabled(False)
            self.action_close.setEnabled(True)
            self.action_save.setEnabled(True)
            self.action_select_function.setEnabled(True)
            self.action_analyze.setEnabled(True)
            self.action_quit.setEnabled(True)     
            self.span.set_active(False)
        else:
            print('Illegal state')
                                          


# Standard main loop code
if __name__ == '__main__':
    import sys
#    sys.tracbacklimit = 10
    app = widgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())


### Old
#     def _write_results(self):
#         r = self.blits_data.results
#         tbr = self.tblResults
#         tbr.setColumnCount(len(r.columns))
#         tbr.setRowCount(len(r.index))
#         tbr.setVerticalHeaderLabels(r.index)
#         tbr.setHorizontalHeaderLabels(r.columns)
#         for i in range(len(r.index)):
#             for j in range(len(r.columns)):
#                 tbr.setItem(i,j,widgets.QTableWidgetItem(str(r.iat[i, j])))
# 
#         if self.blits_data.results_acquired['fractional saturation']:
#             p = self.blits_data.get_fractional_saturation_params_dataframe()
#             tbp = self.tblFitParams
#             tbp.setColumnCount(len(p.columns))
#             tbp.setRowCount(len(p.index))
#             tbp.setVerticalHeaderLabels(p.index)
#             tbp.setHorizontalHeaderLabels(p.columns)
#             for i in range(len(p.index)):
#                 for j in range(len(p.columns)):
#                     tbp.setItem(i,j,widgets.QTableWidgetItem(str(p.iat[i, j])))
#             
#             f = self.blits_data.get_fractional_saturation_curve()
#             tbf = self.tblFittedCurve
#             tbf.setColumnCount(len(f.columns))
#             tbf.setRowCount(len(f.index))
#             tbf.setHorizontalHeaderLabels(f.columns)
#             for i in range(len(f.index)):
#                 for j in range(len(f.columns)):
#                     tbf.setItem(i,j,widgets.QTableWidgetItem(str(f.iat[i, j])))        


