"""
Blits:
Created on 23 May 2017
Original Blivion:
Created on Tue Oct 25 13:11:32 2016

@author: Maria Schilstra
"""

#from PyQt5.uic import loadUiType

from PyQt5 import QtCore as qt
from PyQt5 import QtWidgets as widgets
from PyQt5 import QtGui as gui

from matplotlib.widgets import SpanSelector
from blitspak.blits_mpl import MplCanvas, NavigationToolbar
from blitspak.blits_data import BlitsData
from blitspak.scrutinize_dialog import ScrutinizeDialog
from blitspak.function_dialog import FunctionSelectionDialog
#import blitspak.blits_ui as ui
from PyQt5.uic import loadUiType
Ui_MainWindow, QMainWindow = loadUiType('..\\..\\Resources\\UI\\blits.ui')


# from blitspak.simulate_dialog import SimulateDialog
# import functions.framework as ff
# import functions.function_defs as fdefs

# Original:
# To avoid using .ui file (from QtDesigner) and loadUIType, 
# created a python-version of the .ui file using pyuic5 from command line
# Here: pyuic5 blits.ui -o blits_ui.py
# Also: cannot (easily) use .qrc file, so need to create _rc.py file
# with icon definitions: pyrcc5 -o blits_rc.py blits.qrc
# Then import .py package, as below.
# (QMainWindow is a QtWidget; UI_MainWindow is generated by the converted .ui)



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)

        self.scrutinize_dialog = None
        self.function_dialog = None
        
        self.canvas = MplCanvas(self.mpl_window)
        self.plot_toolbar = NavigationToolbar(self.canvas, self.mpl_window)
        self.mpl_layout.addWidget(self.canvas)
        self.frm_show_axis = widgets.QFrame()
        self.axis_layout = widgets.QHBoxLayout()
        self.frm_show_axis.setLayout(self.axis_layout)
        self.mpl_layout.addWidget(self.frm_show_axis)
        self.mpl_layout.addWidget(self.plot_toolbar)

        self.action_open.triggered.connect(self.on_open)
        self.action_create.triggered.connect(self.on_create)
        self.action_close.triggered.connect(self.on_close_data)
        self.action_save.triggered.connect(self.on_save)
        self.action_function.triggered.connect(self.on_function)
        self.action_analyze.triggered.connect(self.on_analyze)
        self.action_quit.triggered.connect(self.close)     

        self.span = SpanSelector(self.canvas.data_plot, self.on_select_span, 
        'horizontal', useblit=True, rectprops=dict(alpha=0.5, facecolor='red'))
        
        self.action_open.setEnabled(True)
        self.action_create.setEnabled(True)
        self.action_close.setEnabled(False)
        self.action_save.setEnabled(False)
        self.action_function.setEnabled(False)
        self.action_analyze.setEnabled(False)
        self.action_quit.setEnabled(True)     
        self.span.set_active(False)
        
        self.blits_data = BlitsData()
        self.file_name = ""
        self.file_path = ""
        self.phase_number = 0
        self.phase_name = "Phase"
        self.phase_list = []
        self.current_function = ""
        self.function_dialog = FunctionSelectionDialog(self, self.current_function)

        self._data_open = False
        self._scrutinizing = False
                                        
    def on_open(self):
        file_path = widgets.QFileDialog.getOpenFileName(self, 
        "Open Data File", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if file_path:
            self.file_path = file_path
            info = qt.QFileInfo(file_path)
            self.blits_data.file_name = info.fileName()
            if self._data_open:
                self.on_close()
            self.blits_data.import_data(file_path)
            self.canvas.set_colours(self.blits_data.series_names.tolist())
            for key in self.blits_data.series_names:
                series = self.blits_data.series_dict[key]
                x = series.iloc[:, 0]
                y = series['y']
                self.canvas.draw_series(key, x, y)

            self.action_analyze.setEnabled(True)
            self._data_open = True
            self._scrutinizing = False
            
            self.action_open.setEnabled(False)        
            self.action_create.setEnabled(False)
            self.action_close.setEnabled(True)
            self.action_save.setEnabled(True)
            self.action_function.setEnabled(True)
            self.action_analyze.setEnabled(True)
            self.action_quit.setEnabled(True)     
            self.span.set_active(False)
            
    def on_create(self):   
        # code to create (simulate) data set here 
        # needs a bit more thinking
        self.action_open.setEnabled(False)        
        self.action_create.setEnabled(False)
        self.action_close.setEnabled(True)
        self.action_save.setEnabled(True)
        self.action_function.setEnabled(True)
        self.action_analyze.setEnabled(True)
        self.action_quit.setEnabled(True)     
        self.span.set_active(False)
 
    def on_close_data(self):
        self.blits_data = BlitsData()
        self.canvas.clear_figure()
        self._data_open = False
        self._scrutinizing = False
        self._simulating = False
            
        self.action_open.setEnabled(True)
        self.action_create.setEnabled(True)
        self.action_close.setEnabled(False)
        self.action_save.setEnabled(False)
        self.action_function.setEnabled(False)
        self.action_analyze.setEnabled(False)
        self.action_quit.setEnabled(True)     
        self.span.set_active(False)
    
    def on_function(self):
        if widgets.QDialog.Accepted == self.function_dialog.exec():
            self.current_function = self.function_dialog.get_selected_function()
        if not self.current_function is None:
            print("Funcion: " + self.current_function.name)
        else:
            print("Funcion: None")
        
        self.model = ParametersTableModel(self.current_function)
        self.tableview = widgets.QTableView()
        table_label = widgets.QLabel(self.current_function.name)
        table_label.setBuddy(self.tableview)
        self.tableview.setModel(self.model)
        self.params_layout.addWidget(self.tableview)




            
    def on_analyze(self):
        if self.action_analyze.isChecked():
            self.plot_toolbar.switch_off_pan_zoom()
            self._scrutinizing = True
            self.span.set_active(True)   
        else:
            self._scrutinizing = False
            self.span.set_active(False)  

    def on_save(self):
        file_path = widgets.QFileDialog.getSaveFileName(self, 
        "Save Results File", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if file_path:
            self.blits_data.export_results(file_path)
        
        
            
    def on_select_span(self, xmin, xmax):
        self.span.set_active(False)
        if self._scrutinizing:  
            if (xmin != xmax):
                phase_id = self.phase_name + '{:0d}'.format(self.phase_number + 1)
                self.scrutinize_dialog = ScrutinizeDialog(main, xmin, xmax) 
                flags = self.scrutinize_dialog.windowFlags() | qt.Qt.WindowMinMaxButtonsHint
                self.scrutinize_dialog.setWindowFlags(flags)
                if self.scrutinize_dialog.show() == widgets.QDialog.Accepted:
                    print(self.scrutinize_dialog.data)
                    self.phase_number += 1
                    self.phase_list.append(phase_id)
                    model = self.scrutinize_dialog.current_function
                    model_expr = self.scrutinize_dialog.fn_dictionary[model][self.scrutinize_dialog.d_expr]
                    m_string = model + ': ' + model_expr
                    tbl_results = self.scrutinize_dialog.tbl_results
                    self._create_results_tab(phase_id, m_string, tbl_results)
                self.action_analyze.setChecked(False)
                self.on_analyze()
                
    def _create_results_tab(self, phase_id, model_string, results_table):
        new_tab = widgets.QWidget()
        lo = widgets.QVBoxLayout(new_tab)
        x = widgets.QLabel(model_string)
        lo.addWidget(x)
        lo.addWidget(results_table)
        new_tab.setLayout(lo)
        
        self.tabWidget.addTab(new_tab, phase_id)
        

            
    def line_icon(self, color):
        pixmap = gui.QPixmap(50,10)
        pixmap.fill(gui.QColor(color))
        icon = gui.QIcon(pixmap)
        return icon  
    
    def circle_icon(self, color):
        pix = gui.QPixmap(30,30)
        pix.fill(gui.QColor("transparent"))
        paint = gui.QPainter()
        paint.begin(pix)
        paint.setBrush(gui.QColor(color))
        paint.setPen(gui.QColor("transparent"))
        paint.drawEllipse(0,0,30,30)
        paint.end()
        icon = gui.QIcon(pix)
        return icon        

    def is_number(self, s):
        try:
            float(s)
            return True
        except ValueError:
            return False    
        
class ParametersTableModel(qt.QAbstractTableModel):
    
    def __init__(self, modfunc):  
        super(ParametersTableModel, self).__init__() 
        self.modfunc = modfunc 
        self.pnames = self.modfunc.parameters
        
    def headerData(self, section, orientation, role=qt.Qt.DisplayRole):
        # Implementation of super.headerData
        if role == qt.Qt.TextAlignmentRole:
            if orientation == qt.Qt.Horizontal:
                return qt.QVariant(int(qt.Qt.AlignLeft|qt.Qt.AlignVCenter))
            return qt.QVariant(int(qt.Qt.AlignRight|qt.Qt.AlignVCenter))
        if role != qt.Qt.DisplayRole:
            return qt.QVariant()
        if orientation == qt.Qt.Vertical:
            for i in range(len(self.pnames)):
                if section == i:
                    return qt.QVariant(self.pnames[i])
#             if section == 0:
#                 return qt.QVariant("p0")
#             elif section == 1:
#                 return qt.QVariant("p1")
#             elif section == 2:
#                 return qt.QVariant("p2")
        
        
#             if section == FNAME:
#                 return qt.QVariant("Name")
#             elif section == INDEPENDENTS:
#                 return qt.QVariant("Independents")
#             elif section == PARAMS:
#                 return qt.QVariant("Parameters")
#             elif section == DESCRIPTION:
#                 return qt.QVariant("Description")
#             elif section == DEFINITION:
#                 return qt.QVariant("Definition")
        return qt.QVariant(int(section + 1))

    def rowCount(self, index=qt.QModelIndex()):
        return len(self.modfunc.parameters) 

    def columnCount(self, index=qt.QModelIndex()):
        return 2
    
    def data(self, index, role=qt.Qt.DisplayRole):
        pass
#         if not index.isValid() or \
#            not (0 <= index.row() < len(self.modfuncs)):
#             return qt.QVariant()
#         column = index.column()
#         if role == qt.Qt.DisplayRole:
#             if column == 0:
#                 return qt.QVariant(self.parameters[0])
#             if column == 1:
#                 return qt.QVariant(self.parameters[1])
#             if column == 2:
#                 return qt.QVariant(self.parameters[2])
        
        
#         if role == qt.Qt.DisplayRole:
#             if column == FNAME:
#                 return qt.QVariant(modfunc.name)
#             elif column == INDEPENDENTS:
#                 return qt.QVariant(modfunc.independents)
#             elif column == PARAMS:
#                 return qt.QVariant(modfunc.parameters)
#             elif column == DESCRIPTION:
#                 return qt.QVariant(modfunc.description)
#             elif column == DEFINITION:
#                 return qt.QVariant(modfunc.definition)
#         elif role == qt.Qt.ToolTipRole:
#             if column == FNAME:
#                 return qt.QVariant(modfunc.name)
#             elif column == INDEPENDENTS:
#                 return qt.QVariant(modfunc.independents)
#             elif column == PARAMS:
#                 return qt.QVariant(modfunc.parameters)
#             elif column == DESCRIPTION:
#                 return qt.QVariant(modfunc.long_description)
#             elif column == DEFINITION:
#                 return qt.QVariant(modfunc.definition)
        return qt.QVariant()        
  

#     def _write_results(self):
#         r = self.blits_data.results
#         tbr = self.tblResults
#         tbr.setColumnCount(len(r.columns))
#         tbr.setRowCount(len(r.index))
#         tbr.setVerticalHeaderLabels(r.index)
#         tbr.setHorizontalHeaderLabels(r.columns)
#         for i in range(len(r.index)):
#             for j in range(len(r.columns)):
#                 tbr.setItem(i,j,widgets.QTableWidgetItem(str(r.iat[i, j])))
# 
#         if self.blits_data.results_acquired['fractional saturation']:
#             p = self.blits_data.get_fractional_saturation_params_dataframe()
#             tbp = self.tblFitParams
#             tbp.setColumnCount(len(p.columns))
#             tbp.setRowCount(len(p.index))
#             tbp.setVerticalHeaderLabels(p.index)
#             tbp.setHorizontalHeaderLabels(p.columns)
#             for i in range(len(p.index)):
#                 for j in range(len(p.columns)):
#                     tbp.setItem(i,j,widgets.QTableWidgetItem(str(p.iat[i, j])))
#             
#             f = self.blits_data.get_fractional_saturation_curve()
#             tbf = self.tblFittedCurve
#             tbf.setColumnCount(len(f.columns))
#             tbf.setRowCount(len(f.index))
#             tbf.setHorizontalHeaderLabels(f.columns)
#             for i in range(len(f.index)):
#                 for j in range(len(f.columns)):
#                     tbf.setItem(i,j,widgets.QTableWidgetItem(str(f.iat[i, j])))        
# Standard main loop code
if __name__ == '__main__':
    import sys
#    sys.tracbacklimit = 10
    app = widgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())


